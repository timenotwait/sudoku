import { stateManager } from './stateManager';
import { userGrid } from './grid';
import { backtrack } from './backtrack';
import { candidates as Candidate } from './candidates';
import { encodeOriginSudoku, decodeSencodeForGrid } from '@sudoku/sencode/index'
import { cursor } from '@sudoku/stores/cursor'
import { SUDOKU_SIZE} from '@sudoku/constants'
import { writable,derived } from 'svelte/store';

function createUndoRedoManager() {
    const undoList = [];    // 撤销
    const redoList = [];    // 重做
    const backtrackList = [];   // 回溯
    const removeStateCandidate = writable(new Map());    // 存放回溯去掉的候选值，键是index，值是也是字典{key:pos, value:[removeCandidate, ...]}, pos是 x+y*SUDOKU_SIZE

    return {
        newAction(index) {
            undoList.push(index);
            console.log(undoList);
            redoList.length = 0;
        },
        newBranch(index, x, y, num) {
            let backtrackItem = []
            backtrackItem.push(index);
            backtrackItem.push(x);
            backtrackItem.push(y);
            backtrackItem.push(num);
            
            backtrackList.push(backtrackItem);
            // console.log('backtrackList');
            // console.log(backtrackList);
        },
        undo() {
            if(undoList.length > 1) {
                const oldIndex = undoList.pop();
                userGrid.setGrid(decodeSencodeForGrid(stateManager.get_state(undoList[undoList.length-1])));
                Candidate.syncWithStrategy();
                redoList.push(oldIndex);
            }
            else {
                console.log('Nothing to undo.');
            }
        },
        redo() {
            if(redoList.length > 0) {
                const oldIndex = redoList.pop();
                userGrid.setGrid(decodeSencodeForGrid(stateManager.get_state(oldIndex)));
                Candidate.syncWithStrategy();
                undoList.push(oldIndex);
            }
            else {
                console.log('Nothing to redo.');
            }
        },
        returnToBranch() {
            if(backtrackList.length > 0) {
                let backtrackItem = backtrackList.pop();
                let index = backtrackItem[0];
                let x = backtrackItem[1];
                let y = backtrackItem[2];
                let num = backtrackItem[3];

                userGrid.setGrid(decodeSencodeForGrid(stateManager.get_state(index)));
                cursor.set(x, y);
                Candidate.syncWithStrategy();
                // undoList pop至分支点
                let undoListLastIndex = undoList.length - 1;
                while(undoListLastIndex >= 1 && undoList[undoList.length - 1] != index) {
                    undoList.pop();
                    undoListLastIndex = undoList.length - 1;
                }
                redoList.length = 0;
                // backtrack.toggle();

                // 更新removeStateCandidate
                // if(!removeStateCandidate.has(index)) {
                //     let value = new Map();
                //     value.set(x+y*SUDOKU_SIZE, [num]);
                //     removeStateCandidate.set(index, value);
                // }
                // else {
                //     let stateRemovedCandidate = removeStateCandidate.get(index);
                //     if(!stateRemovedCandidate.has(x+y*SUDOKU_SIZE)) {  // 该位置的候选值没有去掉
                //         stateRemovedCandidate.set(x+y*SUDOKU_SIZE, [num]);
                //     }
                //     else {
                //         let newRemovedCandidate = stateRemovedCandidate.get(x+y*SUDOKU_SIZE);
                //         newRemovedCandidate.push(num);
                //         stateRemovedCandidate.set(x+y*SUDOKU_SIZE, newRemovedCandidate);
                //     }
                //     removeStateCandidate.set(index, stateRemovedCandidate);
                // }

                if(!this.removeCandidateHas(index)) {
                    console.log(1);
                    let value = new Map();
                    value.set(x+y*SUDOKU_SIZE, [num]);
                    console.log(2);
                    console.log(value);
                    this.removeCandidateSet(index, value);
                }
                else{
                    let a = this.removeCandidateGet(index);
                    if(!a.has(x+y*SUDOKU_SIZE)) {
                        a.set(x+y*SUDOKU_SIZE, [num]);
                    }
                    else {
                        let b = a.get(x+y*SUDOKU_SIZE);
                        b.push(num);
                        a.set(x+y*SUDOKU_SIZE, b);
                    }
                    this.removeCandidateSet(index, a);
                }
                
                // console.log('removeStateCandidate');
                // console.log(removeStateCandidate);
            }
            else {
                console.log('Nothing to backtrack');
            }
        },
        getUndoListSize() {
            return undoList.length;
        },
        getRemoveStateCandidate:(index) => {
            let currentRemoveStateCandidate;
			removeStateCandidate.subscribe($removeStateCandidate => {
				currentRemoveStateCandidate = $removeStateCandidate;
			})();
			return currentRemoveStateCandidate.get(index);
            // return removeStateCandidate.get(index);
        },
        removeCandidateHas:(index) => {
            removeStateCandidate.subscribe(map => {
                console.log('map');
                console.log(map);
                return map.has(index);
            })
        },
        removeCandidateGet:(index) => {
            let value;
            removeStateCandidate.subscribe(map => {
                value = map.get(index);
            })();
            return value;
        },
        removeCandidateSet:(index, value) => {
            removeStateCandidate.update(map => {
                if(!map.has(index)) {
                    map.set(index, [value]);
                    console.log(map);
                }
                else {
                    let temp = map.get(index);
                    temp.push(value);
                    map.set(index, temp);
                }
                return map;
            })
        }
    }
}

export const UndoRedoManager = createUndoRedoManager();