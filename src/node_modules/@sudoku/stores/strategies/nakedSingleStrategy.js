export class NakedSingleStrategy {
    constructor() {}

    // 执行Naked Single策略
    execute(grid, candidates) {
        const newCandidates = JSON.parse(JSON.stringify(candidates)); // 深拷贝避免直接修改原数据
        // 记录总体移除的候选数
        let totalRemoved = 0;
        const maxIterOfStrategy = 1000;
        // 设置迭代上限
        for (let i = 0; i < maxIterOfStrategy; i++) {
            let removed = 0;
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (this.isNakedSingle(newCandidates[row][col])) {
                        const number = newCandidates[row][col][0];
                        removed += this.updateCandidates(row, col, number, newCandidates);
                    }
                }
            }
            totalRemoved += removed;
            if (removed === 0) {
                break;
            }
        }
        // if (totalRemoved !== 0) {
        //     console.log(`Naked Single Strategy: ${totalRemoved} candidates removed.`);
        // }
        return totalRemoved, newCandidates;
    }

    // 判断是否为Naked Single
    isNakedSingle(cellCandidates) {
        return cellCandidates.length === 1;
    }

    // 更新候选数字列表
    updateCandidates(row, col, number, candidates) {
        let removed = 0;
        // 移除当前行、列和小方块中的相同数字
        for (let i = 0; i < 9; i++) {
            // 移除当前行中的候选数字
            if (i !== col && candidates[row][i].includes(number)) {
                candidates[row][i] = candidates[row][i].filter(n => n !== number);
                removed++;
            }
            // 移除当前列中的候选数字
            if (i !== row && candidates[i][col].includes(number)) {
                candidates[i][col] = candidates[i][col].filter(n => n !== number);
                removed++;
            }
        }

        // 移除当前3x3小方块中的候选数字
        const startRow = Math.floor(row / 3) * 3;
        const startCol = Math.floor(col / 3) * 3;
        for (let r = startRow; r < startRow + 3; r++) {
            for (let c = startCol; c < startCol + 3; c++) {
                if ((r !== row || c !== col) && candidates[r][c].includes(number)) {
                    candidates[r][c] = candidates[r][c].filter(n => n !== number);
                    removed++;
                }
            }
        }
        return removed;
    }
}


// 单元测试
import { test } from "./strategyTestFunction.js";
const input_sencode = "[46][69][9][12567][12567]83[19][1579]7[38]2[135]9[35]46[15]15[39][367][67]42[89][79]9[2367]48[2567][23567]1[23][2367][2568][23678][357][2345679][24567]1[679][2349][234679][26][12367][137][234679][2467][23679][679]58[25][1279]8[1245679][124567][25679][569][12349][1234569]346[12579][12578][2579][589][1289][1259][25][129][159][124569]3[2569][5689]7[124569]";
const expect_output_sencode = "[4][6][9][25][25]83[1][7]7[8]2[1]9[3]46[5]15[3][67][67]42[8][9]9[237]48[2567][2567]1[23][236][2568][237][57][2345679][24567]1[679][2349][2346][26][1237][17][234679][2467][2679][679]58[25][1279]8[245679][124567][25679][569][2349][12346]346[2579][12578][2579][589][29][12][25][129][15][24569]3[2569][5689]7[1246]";

// test(input_sencode, expect_output_sencode, new NakedSingleStrategy(), "Naked Single");
