export class HiddenSingleStrategy {
    constructor() {}

    // 执行Hidden Single策略
    execute(grid, candidates) {
        const newCandidates = JSON.parse(JSON.stringify(candidates)); // 深拷贝避免直接修改原数据

        // 记录总体移除的候选数
        let totalRemoved = 0;
        const maxIterOfStrategy = 1000;
        // 设置迭代上限
        for (let i = 0; i < maxIterOfStrategy; i++) {
            let removedCount = 0;
            // 处理每一行
            for (let row = 0; row < 9; row++) {
                removedCount += this.processRow(row, newCandidates);
            }

            // 处理每一列
            for (let col = 0; col < 9; col++) {
                removedCount += this.processColumn(col, newCandidates);
            }

            // 处理每一个3x3的小方块
            for (let block = 0; block < 9; block++) {
                removedCount += this.processBlock(block, newCandidates);
            }
            totalRemoved += removedCount;
            if (removedCount === 0) {
                break;
            }
        }
        // return { updatedCandidates: newCandidates, removed: totalRemoved };
        // if (totalRemoved !== 0) {
        //     console.log("Hidden Single Strategy removed candidate count:", totalRemoved);
        // }
        return totalRemoved, newCandidates;
    }

    // 处理一行
    processRow(rowIndex, candidates) {
        let removedCount = 0;
        const digitCounts = Array(10).fill(0); // 索引从0开始，所以长度为10
        const digitPositions = Array.from({ length: 10 }, () => []);

        // 统计每个数字在该行内的出现次数及其位置
        candidates[rowIndex].forEach((cell, colIndex) => {
            cell.forEach(digit => {
                digitCounts[digit]++;
                digitPositions[digit].push(colIndex);
            });
        });

        // 应用Hidden Single策略
        for (let digit = 1; digit <= 9; digit++) {
            if (digitCounts[digit] === 1) {
                const position = digitPositions[digit][0];
                if (candidates[rowIndex][position].length > 1) {
                    removedCount += candidates[rowIndex][position].length - 1;
                    candidates[rowIndex][position] = [digit];
                }
            }
        }

        return removedCount;
    }
    // 处理一列
    processColumn(colIndex, candidates) {
        let removedCount = 0;
        const digitCounts = Array(10).fill(0); // 索引从0开始，所以长度为10
        const digitPositions = Array.from({ length: 10 }, () => []);

        // 统计每个数字在该列内的出现次数及其位置
        for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
            candidates[rowIndex][colIndex].forEach(digit => {
                digitCounts[digit]++;
                digitPositions[digit].push(rowIndex);
            });
        }

        // 应用Hidden Single策略
        for (let digit = 1; digit <= 9; digit++) {
            if (digitCounts[digit] === 1) {
                const position = digitPositions[digit][0];
                if (candidates[position][colIndex].length > 1) {
                    removedCount += candidates[position][colIndex].length - 1;
                    candidates[position][colIndex] = [digit];
                }
            }
        }

        return removedCount;
    }

    // 处理一个3x3的小方块
    processBlock(blockIndex, candidates) {
        let removedCount = 0;
        const digitCounts = Array(10).fill(0); // 索引从0开始，所以长度为10
        const digitPositions = Array.from({ length: 10 }, () => []);
        const blockCells = [];

        // 获取小方块中的所有单元格
        const startRow = Math.floor(blockIndex / 3) * 3;
        const startCol = (blockIndex % 3) * 3;

        for (let row = startRow; row < startRow + 3; row++) {
            for (let col = startCol; col < startCol + 3; col++) {
                blockCells.push({ row, col, value: candidates[row][col] });
            }
        }

        // 统计每个数字在该小方块内的出现次数及其位置
        blockCells.forEach(({ row, col, value }) => {
            value.forEach(digit => {
                digitCounts[digit]++;
                digitPositions[digit].push({ row, col });
            });
        });

        // 应用Hidden Single策略
        for (let digit = 1; digit <= 9; digit++) {
            if (digitCounts[digit] === 1) {
                const position = digitPositions[digit][0];
                if (candidates[position.row][position.col].length > 1) {
                    removedCount += candidates[position.row][position.col].length - 1;
                    candidates[position.row][position.col] = [digit];
                }
            }
        }

        return removedCount;
    }


    // 处理一个单位（行、列或小方块）
    processUnit(unit) {
        const digitCounts = Array(10).fill(0); // 索引从0开始，所以长度为10
        const digitPositions = Array.from({ length: 10 }, () => []);
        let removedCount = 0;

        // unit.forEach((cell, index) => {
        //     cell.forEach(digit => {
        //         digitCounts[digit]++;
        //         digitPositions[digit].push(index);
        //     });
        // });
        for (let i = 0; i < unit.length; i++) {
            for (let j = 0; j < unit[i].length; j++) {
                const digit = unit[i][j];
                digitCounts[digit]++;
                digitPositions[digit].push(i);
            }
        }

        for (let digit = 1; digit <= 9; digit++) {
            if (digitCounts[digit] === 1) {
                const position = digitPositions[digit][0];
                if (unit[position].length > 1) {
                    removedCount += unit[position].length - 1; // 计算移除的候选值数量
                    unit[position] = [digit];
                }
            }
        }

        return removedCount;
    }

    // 获取某一列
    getColumn(colIndex, candidates) {
        let column = [];
        for (let row = 0; row < 9; row++) {
            column.push(candidates[row][colIndex]);
        }
        return column;
    }

    // 获取某一小方块
    getBlock(blockIndex, candidates) {
        let block = [];
        let startRow = Math.floor(blockIndex / 3) * 3;
        let startCol = (blockIndex % 3) * 3;

        for (let row = startRow; row < startRow + 3; row++) {
            let blockRow = [];
            for (let col = startCol; col < startCol + 3; col++) {
                blockRow.push(candidates[row][col]);
            }
            block.push(blockRow);
        }
        return block;
    }
}

// 单元测试
import { test } from "./strategyTestFunction.js";
const input_sencode = "[379][1679]4[123567][2357]8[2356][79][23567][37][678][3678][23567][2357]941[235678]25[13678][13467][347][6][36][9][3678][4579]3[2578][124579][24579][127][1256][478][1245678]1[2478][2578][23457]6[237][25][478]96[2479][257][124579]8[127][125]3[12457][3][126][1236][8][9]475[13][347][1467]9[6][37]582[134]8[247][2357][237]1[237]96[34]";
const expect_output_sencode = "[379][1679]4[123567][2357]8[2356][79][23567][37][678][3678][23567][2357]941[235678]25[13678][13467][347][6][36][9][3678][4579]3[2578][124579][24579][127][1256][478][1245678]1[2478][2578][23457]6[237][25][478]96[2479][257][124579]8[127][125]3[12457][3][126][1236][8][9]475[13][347][1467]9[6][37]582[134]8[247][5][237]1[237]96[34]";

// test(input_sencode, expect_output_sencode, new HiddenSingleStrategy(), "Hidden Single");

// var strategy = new HiddenSingleStrategy();
// var result = strategy.execute(candidates);
// console.log(result.updatedCandidates);
// console.log("Removed candidate count:", result.removed);