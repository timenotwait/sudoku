import { StrategyTemplate } from '../strategyTemplate'

export class HiddenSingleStrategy extends StrategyTemplate {
    constructor() {
        super("Hidden Single Strategy");
    }

    // 执行Hidden Single策略
    execute(grid, candidates, hint_step) {
        const newCandidates = JSON.parse(JSON.stringify(candidates)); // 深拷贝避免直接修改原数据

        // 记录总体移除的候选数
        let totalRemoved = 0;
        const maxIterOfStrategy = hint_step;
        // console.log(hint_step)
        // 设置迭代上限
        for (let i = 0; i < maxIterOfStrategy; i++) {
            let removedCount = 0;
            // 处理每一行
            for (let row = 0; row < 9; row++) {
                removedCount += this.processRow(row, newCandidates);
            }

            // 处理每一列
            for (let col = 0; col < 9; col++) {
                removedCount += this.processColumn(col, newCandidates);
            }

            // 处理每一个3x3的小方块
            for (let block = 0; block < 9; block++) {
                removedCount += this.processBlock(block, newCandidates);
            }
            totalRemoved += removedCount;
            if (removedCount === 0) {
                break;
            }
        }
        return { updatedCandidates: newCandidates, removed: totalRemoved };
    }

    // 处理一行
    processRow(rowIndex, candidates) {
        let removedCount = 0;
        const digitCounts = Array(10).fill(0); // 索引从0开始，所以长度为10
        const digitPositions = Array.from({ length: 10 }, () => []);

        // 统计每个数字在该行内的出现次数及其位置
        candidates[rowIndex].forEach((cell, colIndex) => {
            cell.forEach(digit => {
                digitCounts[digit]++;
                digitPositions[digit].push(colIndex);
            });
        });

        // 应用Hidden Single策略
        for (let digit = 1; digit <= 9; digit++) {
            if (digitCounts[digit] === 1) {
                const position = digitPositions[digit][0];
                if (candidates[rowIndex][position].length > 1) {
                    removedCount += candidates[rowIndex][position].length - 1;
                    candidates[rowIndex][position] = [digit];
                }
            }
        }

        return removedCount;
    }
    // 处理一列
    processColumn(colIndex, candidates) {
        let removedCount = 0;
        const digitCounts = Array(10).fill(0); // 索引从0开始，所以长度为10
        const digitPositions = Array.from({ length: 10 }, () => []);

        // 统计每个数字在该列内的出现次数及其位置
        for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
            candidates[rowIndex][colIndex].forEach(digit => {
                digitCounts[digit]++;
                digitPositions[digit].push(rowIndex);
            });
        }

        // 应用Hidden Single策略
        for (let digit = 1; digit <= 9; digit++) {
            if (digitCounts[digit] === 1) {
                const position = digitPositions[digit][0];
                if (candidates[position][colIndex].length > 1) {
                    removedCount += candidates[position][colIndex].length - 1;
                    candidates[position][colIndex] = [digit];
                }
            }
        }

        return removedCount;
    }

    // 处理一个3x3的小方块
    processBlock(blockIndex, candidates) {
        let removedCount = 0;
        const digitCounts = Array(10).fill(0); // 索引从0开始，所以长度为10
        const digitPositions = Array.from({ length: 10 }, () => []);
        const blockCells = [];

        // 获取小方块中的所有单元格
        const startRow = Math.floor(blockIndex / 3) * 3;
        const startCol = (blockIndex % 3) * 3;

        for (let row = startRow; row < startRow + 3; row++) {
            for (let col = startCol; col < startCol + 3; col++) {
                blockCells.push({ row, col, value: candidates[row][col] });
            }
        }

        // 统计每个数字在该小方块内的出现次数及其位置
        blockCells.forEach(({ row, col, value }) => {
            value.forEach(digit => {
                digitCounts[digit]++;
                digitPositions[digit].push({ row, col });
            });
        });

        // 应用Hidden Single策略
        for (let digit = 1; digit <= 9; digit++) {
            if (digitCounts[digit] === 1) {
                const position = digitPositions[digit][0];
                if (candidates[position.row][position.col].length > 1) {
                    removedCount += candidates[position.row][position.col].length - 1;
                    candidates[position.row][position.col] = [digit];
                }
            }
        }

        return removedCount;
    }
}
