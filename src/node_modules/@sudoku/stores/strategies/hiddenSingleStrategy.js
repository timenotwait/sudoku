import { StrategyTemplate } from '../strategyTemplate'

export class HiddenSingleStrategy extends StrategyTemplate {
    constructor() {
        super("Hidden Single Strategy");
    }

    // 执行Hidden Single策略
    execute(grid, candidates, hint_step) {
        const newCandidates = JSON.parse(JSON.stringify(candidates)); // 深拷贝避免直接修改原数据

        // 记录总体移除的候选数
        let totalRemoved = 0;
        const maxIterOfStrategy = hint_step;
        // console.log(hint_step)
        // 设置迭代上限
        for (let i = 0; i < maxIterOfStrategy; i++) {
            let removedCount = 0;
            // 处理每一行
            for (let row = 0; row < 9; row++) {
                removedCount += this.processRow(row, newCandidates);
            }

            // 处理每一列
            for (let col = 0; col < 9; col++) {
                removedCount += this.processColumn(col, newCandidates);
            }

            // 处理每一个3x3的小方块
            for (let block = 0; block < 9; block++) {
                removedCount += this.processBlock(block, newCandidates);
            }
            totalRemoved += removedCount;
            if (removedCount === 0) {
                break;
            }
        }
        // if (totalRemoved !== 0) {
        //     console.log(`Hidden Single Strategy: removed ${totalRemoved} candidates`);
        // }
        // return totalRemoved, newCandidates;
        return { updatedCandidates: newCandidates, removed: totalRemoved };
    }

    // 处理一行
    processRow(rowIndex, candidates) {
        let removedCount = 0;
        const digitCounts = Array(10).fill(0); // 索引从0开始，所以长度为10
        const digitPositions = Array.from({ length: 10 }, () => []);

        // 统计每个数字在该行内的出现次数及其位置
        candidates[rowIndex].forEach((cell, colIndex) => {
            cell.forEach(digit => {
                digitCounts[digit]++;
                digitPositions[digit].push(colIndex);
            });
        });

        // 应用Hidden Single策略
        for (let digit = 1; digit <= 9; digit++) {
            if (digitCounts[digit] === 1) {
                const position = digitPositions[digit][0];
                if (candidates[rowIndex][position].length > 1) {
                    removedCount += candidates[rowIndex][position].length - 1;
                    candidates[rowIndex][position] = [digit];
                }
            }
        }

        return removedCount;
    }
    // 处理一列
    processColumn(colIndex, candidates) {
        let removedCount = 0;
        const digitCounts = Array(10).fill(0); // 索引从0开始，所以长度为10
        const digitPositions = Array.from({ length: 10 }, () => []);

        // 统计每个数字在该列内的出现次数及其位置
        for (let rowIndex = 0; rowIndex < 9; rowIndex++) {
            candidates[rowIndex][colIndex].forEach(digit => {
                digitCounts[digit]++;
                digitPositions[digit].push(rowIndex);
            });
        }

        // 应用Hidden Single策略
        for (let digit = 1; digit <= 9; digit++) {
            if (digitCounts[digit] === 1) {
                const position = digitPositions[digit][0];
                if (candidates[position][colIndex].length > 1) {
                    removedCount += candidates[position][colIndex].length - 1;
                    candidates[position][colIndex] = [digit];
                }
            }
        }

        return removedCount;
    }

    // 处理一个3x3的小方块
    processBlock(blockIndex, candidates) {
        let removedCount = 0;
        const digitCounts = Array(10).fill(0); // 索引从0开始，所以长度为10
        const digitPositions = Array.from({ length: 10 }, () => []);
        const blockCells = [];

        // 获取小方块中的所有单元格
        const startRow = Math.floor(blockIndex / 3) * 3;
        const startCol = (blockIndex % 3) * 3;

        for (let row = startRow; row < startRow + 3; row++) {
            for (let col = startCol; col < startCol + 3; col++) {
                blockCells.push({ row, col, value: candidates[row][col] });
            }
        }

        // 统计每个数字在该小方块内的出现次数及其位置
        blockCells.forEach(({ row, col, value }) => {
            value.forEach(digit => {
                digitCounts[digit]++;
                digitPositions[digit].push({ row, col });
            });
        });

        // 应用Hidden Single策略
        for (let digit = 1; digit <= 9; digit++) {
            if (digitCounts[digit] === 1) {
                const position = digitPositions[digit][0];
                if (candidates[position.row][position.col].length > 1) {
                    removedCount += candidates[position.row][position.col].length - 1;
                    candidates[position.row][position.col] = [digit];
                }
            }
        }

        return removedCount;
    }
}

// 单元测试
// let json_input_candidate = "[[[3,6,7,9],[],[],[],[4,6,9],[2,4,6,7,9],[3,4,7,9],[3,4,6,7,9],[3,4,7,9]],[[],[3,7,9],[1,6,9],[6,7,9],[4,5,6,9],[4,5,6,7,9],[],[3,4,5,6,7,9],[1,3,4,5,7,9]],[[1,6,7,9],[7,9],[],[],[5,6,8,9],[5,6,7,8,9],[7,9],[5,6,7,9],[]],[[],[2,3,4,5,9],[2,9],[7,9],[],[4,5,7,9],[],[3,4,7,9],[3,4,7,9]],[[3,4,5,6,9],[3,4,5,9],[],[6,8,9],[3,4,5,6,8,9],[4,5,6,8,9],[],[],[3,4,8,9]],[[1,3,4,6,9],[3,4,9],[1,6,9],[6,7,8,9],[],[4,6,7,8,9],[],[3,4,7,8,9],[3,4,7,8,9]],[[4,5,7,9],[2,4,5,7,9],[2,8,9],[2,6,8,9],[6,8,9],[1,2,6,8,9],[3,4,7,9],[2,3,4,5,7,8,9],[3,4,5,7,8,9]],[[5,9],[],[2,8,9],[],[],[],[],[2,5,8,9],[5,8,9]],[[4,7,9],[],[],[],[8,9],[2,8,9],[4,7,9],[2,4,7,8,9],[]]]";
// let json_expect_output_candidate = "[[[3,6,7,9],[],[],[],[4,6,9],[2],[3,4,7,9],[3,4,6,7,9],[3,4,7,9]],[[],[3,7,9],[1,6,9],[6,7,9],[4,5,6,9],[4,5,6,7,9],[],[3,4,5,6,7,9],[1]],[[1],[7,9],[],[],[5,6,8,9],[5,6,7,8,9],[7,9],[5,6,7,9],[]],[[],[2,3,4,5,9],[2,9],[7,9],[],[4,5,7,9],[],[3,4,7,9],[3,4,7,9]],[[3,4,5,6,9],[3,4,5,9],[],[6,8,9],[3],[4,5,6,8,9],[],[],[3,4,8,9]],[[1,3,4,6,9],[3,4,9],[1,6,9],[6,7,8,9],[],[4,6,7,8,9],[],[3,4,7,8,9],[3,4,7,8,9]],[[4,5,7,9],[2,4,5,7,9],[2,8,9],[2],[6],[1],[3,4,7,9],[2,3,4,5,7,8,9],[3,4,5,7,8,9]],[[5,9],[],[2,8,9],[],[],[],[],[2,5,8,9],[5,8,9]],[[4,7,9],[],[],[],[8,9],[2,8,9],[4,7,9],[2,4,7,8,9],[]]]";
// const input_candidate = JSON.parse(json_input_candidate);
// const expect_output_candidate = JSON.parse(json_expect_output_candidate);
// let strategy = new HiddenSingleStrategy();
// let actual_output_candidate = strategy.execute([],input_candidate, 10000).updatedCandidates;
// if (JSON.stringify(actual_output_candidate) === JSON.stringify(expect_output_candidate)) {
//     console.log("Hidden Single Strategy Test passed");
// } else {
//     console.log("Hidden Single Strategy Test failed");
// }